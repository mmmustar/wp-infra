This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-05T16:28:36.433Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
ansible/
  group_vars/
    all.yml
  inventory/
    hosts.yml
  roles/
    common/
      defaults/
        main.yml
      handlers/
        main-rch.yml
      tasks/
        main.yml
    docker/
      defaults/
        main.yml
      handlers/
        main.yml
      tasks/
        main.yml
    k3s/
      defaults/
        main.yml
      handlers/
        main.yml
      tasks/
        main.yml
  ansible.cfg
  requirements.yml
  site.yml
environments/
  backend-config/
    .terraform.lock.hcl
    main.tf
    outputs.tf
    variables.tf
    versions.tf
  modules/
    compute/
      main.tf
      outputs.tf
      variables.tf
    network/
      main.tf
      outputs.tf
      security.tf
      variables.tf
    security/
      main.tf
      outputs.tf
      variables.tf
  prod/
    backend.tf
  test/
    .terraform.lock.hcl
    backend.tf
    main.tf
    variables.tf
.gitignore

================================================================
Files
================================================================

================
File: ansible/group_vars/all.yml
================
# ansible/group_vars/all.yml
---
# Variables globales communes à tous les serveurs
timezone: UTC
environment: test

================
File: ansible/inventory/hosts.yml
================
# ansible/inventory/hosts.yml
---
all:
  children:
    wordpress:
      hosts:
        wp-test:
          ansible_host: 35.180.222.29
          ansible_user: ubuntu
          ansible_ssh_private_key_file: ~/.ssh/test-aws-key-pair-new.pem
          ansible_python_interpreter: /usr/bin/python3

================
File: ansible/roles/common/defaults/main.yml
================
# roles/common/defaults/main.yml
---
system_packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - software-properties-common
  - python3-pip
  - nfs-common

================
File: ansible/roles/common/handlers/main-rch.yml
================
# roles/common/handlers/main.yml
---
- name: restart systemd-resolved
  service:
    name: systemd-resolved
    state: restarted

================
File: ansible/roles/common/tasks/main.yml
================
# roles/common/common/main.yml
---
- block:
    - name: Update package cache
      apt:
        update_cache: yes
      become: true

    - name: Install system packages
      apt:
        name:
          - python3
          - python3-pip
          - git
          - vim
        state: present
      become: true

================
File: ansible/roles/docker/defaults/main.yml
================
# roles/docker/defaults/main.yml
---
docker_users:
  - "{{ ansible_user }}"

================
File: ansible/roles/docker/handlers/main.yml
================
# roles/docker/handlers/main.yml
---
- name: restart docker
  service:
    name: docker
    state: restarted

================
File: ansible/roles/docker/tasks/main.yml
================
- name: Install required packages
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg-agent
      - software-properties-common
    state: present

- name: Add Docker GPG key
  apt_key:
    url: https://download.docker.com/linux/ubuntu/gpg
    state: present

- name: Add Docker repository
  apt_repository:
    repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable
    state: present

- name: Install Docker
  apt:
    name:
      - docker-ce
      - docker-ce-cli
      - containerd.io
      - docker-compose-plugin
    state: present
    update_cache: yes

- name: Start and enable Docker
  service:
    name: docker
    state: started
    enabled: yes

- name: Add users to docker group
  user:
    name: "{{ item }}"
    groups: docker
    append: yes
  with_items: "{{ docker_users }}"

- name: Configure Docker daemon
  copy:
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m",
          "max-file": "3"
        }
      }
    dest: /etc/docker/daemon.json
  notify: restart docker

================
File: ansible/roles/k3s/defaults/main.yml
================
# roles/k3s/defaults/main.yml
---
k3s_version: v1.28.4+k3s2
k3s_server_args: --disable servicelb --disable traefik

================
File: ansible/roles/k3s/handlers/main.yml
================
# roles/k3s/handlers/main.yml
---
- name: restart k3s
  service:
    name: k3s
    state: restarted

================
File: ansible/roles/k3s/tasks/main.yml
================
# roles/k3s/tasks/main.yml
---
- name: Set permissions for k3s config
  file:
    path: /etc/rancher/k3s
    mode: '0755'
    state: directory
  become: true

- name: Set file permissions for k3s.yaml
  file:
    path: /etc/rancher/k3s/k3s.yaml
    mode: '0644'
  become: true

- name: Download k3s installer
  get_url:
    url: https://get.k3s.io
    dest: /tmp/k3s-installer
    mode: '0755'

- name: Install k3s
  command:
    cmd: /tmp/k3s-installer
    creates: /usr/local/bin/k3s
  environment:
    INSTALL_K3S_VERSION: "{{ k3s_version }}"
    INSTALL_K3S_EXEC: "{{ k3s_server_args }}"

- name: Wait for k3s to be up
  wait_for:
    path: /etc/rancher/k3s/k3s.yaml
    delay: 5
    timeout: 300

- name: Create .kube directory
  file:
    path: ~/.kube
    state: directory
    mode: '0700'
  become: false

- name: Configure kubectl for the current user
  copy:
    src: /etc/rancher/k3s/k3s.yaml
    dest: ~/.kube/config
    mode: '0600'
    remote_src: yes
  become: false

- name: Test k3s installation
  command: kubectl get nodes
  register: kubectl_test
  changed_when: false
  become: false

================
File: ansible/ansible.cfg
================
# ansible/ansible.cfg
[defaults]
inventory = inventory/hosts.yml
private_key_file = ~/.ssh/test-aws-key-pair.pem
host_key_checking = False
remote_user = ubuntu
pkg_mgr = yum


[ssh_connection]
pipelining = True

================
File: ansible/requirements.yml
================
# requirements.yml
---
collections:
  - name: kubernetes.core
    version: "2.4.0"
  - name: community.general
    version: "7.5.0"

================
File: ansible/site.yml
================
# ansible/site.yml

- name: Configuration complète des serveurs WordPress
  hosts: wordpress
  become: true

  pre_tasks:
    - name: Install Python 3 if not already installed
      raw: |
        sudo apt update && sudo apt install -y python3
      changed_when: false

  roles:
    - common
    - docker
    - k3s
    
  vars:
    ansible_pkg_mgr: apt

================
File: environments/backend-config/.terraform.lock.hcl
================
# This file is maintained automatically by "terraform init".
# Manual edits may be lost in future updates.

provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.0.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:swP2uqDPi7bRLe+J4oUGEp8ZPTG4NaAV9QK+Iqgo2ro=",
  ]
}

================
File: environments/backend-config/main.tf
================
# environments/backend-config/main.tf

# Un seul bucket S3 pour tous les environnements
resource "aws_s3_bucket" "terraform_state" {
  bucket = "${var.project_name}-terraform-state"

  lifecycle {
    prevent_destroy = true
  }

  tags = {
    Name    = "${var.project_name}-terraform-state"
    Project = var.project_name
  }
}

# Activation du versioning
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}

# Activation du chiffrement
resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Blocage de l'accès public
resource "aws_s3_bucket_public_access_block" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Une seule table DynamoDB pour le verrouillage
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "${var.project_name}-terraform-locks"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = {
    Name    = "${var.project_name}-terraform-locks"
    Project = var.project_name
  }
}

================
File: environments/backend-config/outputs.tf
================
# environments/backend-config/outputs.tf
output "bucket_name" {
  description = "Nom du bucket S3 pour le state Terraform"
  value       = aws_s3_bucket.terraform_state.id
}

output "dynamodb_table_name" {
  description = "Nom de la table DynamoDB pour le verrouillage"
  value       = aws_dynamodb_table.terraform_locks.name
}

================
File: environments/backend-config/variables.tf
================
# environments/backend-config/variables.tf
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "eu-west-3"
}

variable "project_name" {
  description = "Nom du projet"
  type        = string
  default     = "wordpress-mmustar"
}

================
File: environments/backend-config/versions.tf
================
# environments/backend-config/versions.tf
terraform {
  required_version = ">= 1.0.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Project     = var.project_name
      ManagedBy   = "terraform"
    }
  }
}

================
File: environments/modules/compute/main.tf
================
# environments/modules/compute/main.tf
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"] # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

resource "aws_instance" "wordpress" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type
  subnet_id     = var.subnet_id
  key_name      = var.key_name

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  tags = {
    Name        = "${var.project_name}-instance-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }

  lifecycle {
    prevent_destroy = true
  }
}

resource "aws_eip" "wordpress" {
  count    = var.environment == "test" ? 1 : 0
  instance = aws_instance.wordpress.id
  domain   = "vpc"

  tags = {
    Name        = "${var.project_name}-eip-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

================
File: environments/modules/compute/outputs.tf
================
# environments/modules/compute/outputs.tf
output "instance_id" {
  description = "ID of the created EC2 instance"
  value       = aws_instance.wordpress.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = var.environment == "test" ? aws_eip.wordpress[0].public_ip : aws_instance.wordpress.public_ip
}

output "instance_private_ip" {
  description = "Private IP of the EC2 instance"
  value       = aws_instance.wordpress.private_ip
}

================
File: environments/modules/compute/variables.tf
================
# environments/modules/compute/variables.tf
variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID where the EC2 instance will be created"
  type        = string
  default     = "vpc-0385cddb5bd815883"
}

variable "subnet_id" {
  description = "Subnet ID where the EC2 instance will be created"
  type        = string
  default     = "subnet-085d8f8361978d689"
}

variable "security_group_id" {
  description = "Security Group for the EC2 instance"
  type        = string
  default     = "sg-00efe258e85b22a30"
}


variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.medium"
}

variable "key_name" {
  description = "Name of the SSH key pair"
  type        = string
}

================
File: environments/modules/network/main.tf
================
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${var.project_name}-vpc-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name        = "${var.project_name}-igw-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_subnet" "public" {
  count                  = length(var.public_subnet_cidrs)
  vpc_id                 = aws_vpc.main.id
  cidr_block             = var.public_subnet_cidrs[count.index]
  availability_zone      = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name        = "${var.project_name}-public-subnet-${count.index + 1}-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name        = "${var.project_name}-public-rt-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_route_table_association" "public" {
  count = length(var.public_subnet_cidrs)

  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

data "aws_availability_zones" "available" {
  state = "available"
}

================
File: environments/modules/network/outputs.tf
================
# environments/modules/network/outputs.tf
output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}

output "vpc_id" {
  value = aws_vpc.main.id
}

output "route_table_id" {
  value = aws_route_table.public.id
}

================
File: environments/modules/network/security.tf
================
# environments/modules/network/security.tf
resource "aws_security_group" "wordpress" {
  name_prefix = "${var.project_name}-sg-${var.environment}"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]  # À restreindre selon vos besoins
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "${var.project_name}-sg-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

================
File: environments/modules/network/variables.tf
================
# environments/modules/network/variables.tf
variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
  default     = "WP"
}

# environments/modules/network/variables.tf
variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "172.16.0.0/16"  # Modifié pour éviter le conflit avec le RDS VPC
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ["172.16.1.0/24", "172.16.2.0/24"]  # Ajusté en conséquence
}

================
File: environments/modules/security/main.tf
================
# environments/modules/security/main.tf
resource "aws_security_group" "wordpress" {
  name_prefix = "${var.project_name}-wp-${var.environment}"
  description = "Security group for WordPress instance"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTP"
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTPS"
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"] # À restreindre selon vos besoins
    description = "Allow SSH"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }

  tags = {
    Name        = "${var.project_name}-sg-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }

  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_security_group" "rds" {
  name_prefix = "${var.project_name}-rds-${var.environment}"
  description = "Security group for RDS instance"
  vpc_id      = var.vpc_id

  ingress {
    from_port       = 3306
    to_port         = 3306
    protocol        = "tcp"
    security_groups = [aws_security_group.wordpress.id]
    description     = "Allow MySQL from WordPress SG"
  }

  tags = {
    Name        = "${var.project_name}-rds-sg-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

================
File: environments/modules/security/outputs.tf
================
# environments/modules/security/outputs.tf
output "wordpress_sg_id" {
  description = "ID of WordPress security group"
  value       = aws_security_group.wordpress.id
}

output "rds_sg_id" {
  description = "ID of RDS security group"
  value       = aws_security_group.rds.id
}

================
File: environments/modules/security/variables.tf
================
# environments/modules/security/variables.tf
variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID where the security groups will be created"
  type        = string
}

================
File: environments/prod/backend.tf
================
# environments/prod/backend.tf
terraform {
  backend "s3" {
    bucket         = "wordpress-mmustar-terraform-state"
    key            = "environments/prod/terraform.tfstate"
    region         = "eu-west-3"
    dynamodb_table = "wordpress-mmustar-terraform-locks"
    encrypt        = true
  }
}

================
File: environments/test/.terraform.lock.hcl
================
# This file is maintained automatically by "terraform init".
# Manual edits may be lost in future updates.

provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.0.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:swP2uqDPi7bRLe+J4oUGEp8ZPTG4NaAV9QK+Iqgo2ro=",
  ]
}

================
File: environments/test/backend.tf
================
# environments/test/backend.tf
terraform {
  backend "s3" {
    bucket         = "wordpress-mmustar-terraform-state"
    key            = "test/terraform.tfstate"
    region         = "eu-west-3"
    dynamodb_table = "wordpress-mmustar-terraform-locks"
    encrypt        = true
  }
}

================
File: environments/test/main.tf
================
variable "environment" {
  description = "Deployment environment"
  type        = string
}

variable "project_name" {
  description = "Project name for tagging"
  type        = string
}

module "network" {
  source       = "../modules/network"
  environment  = var.environment
  project_name = var.project_name
}

module "security" {
  source       = "../modules/security"
  environment  = var.environment
  project_name = var.project_name
  vpc_id       = module.network.vpc_id
}

module "compute" {
  source            = "../modules/compute"
  environment       = var.environment
  project_name      = var.project_name
  vpc_id            = module.network.vpc_id
  subnet_id         = module.network.public_subnet_ids[0]
  security_group_id = module.security.wordpress_sg_id
  instance_type     = "t3.medium"
  key_name          = "test-aws-key-pair-new"
}

# Association de l'Elastic IP à l'instance EC2
resource "aws_eip" "wordpress_eip" {
  domain     = "vpc"
}

resource "aws_eip_association" "wordpress_eip_assoc" {
  instance_id   = module.compute.instance_id
  allocation_id = aws_eip.wordpress_eip.id
}

# Utilisation de la base de données RDS existante
data "aws_db_instance" "wordpress" {
  db_instance_identifier = "wordpress-db"
}

output "rds_endpoint" {
  value = data.aws_db_instance.wordpress.endpoint
}

output "instance_public_ip" {
  value = module.compute.instance_public_ip
}

output "instance_id" {
  value = module.compute.instance_id
}

output "eip_public_ip" {
  value = aws_eip.wordpress_eip.public_ip
}

================
File: environments/test/variables.tf
================
# environments/test/variables.tf
variable "aws_region" {
  description = "AWS Region"
  type        = string
  default     = "eu-west-3"
}

# SSH key pour instance EC2
variable "key_name" {
  description = "SSH key pair name"
  type        = string
  default     = "test-aws-key-pair-new"  # Remplacez par votre nom de clé
  
}

variable "existing_rds_sg_id" {
  description = "Security Group ID of existing RDS"
  type        = string
}

variable "existing_rds_id" {
  description = "Existing RDS instance ID"
  type        = string
}

variable "existing_vpc_id" {
  description = "ID of the existing VPC"
  type        = string
}

variable "existing_subnet_id" {
  description = "ID of the existing subnet"
  type        = string
}

variable "instance_type" {
  description = "Type of EC2 instance"
  type        = string
  default     = "t3.medium"
}

variable "elastic_ip_allocation_id" {
  description = "Allocation ID of the Elastic IP"
  type        = string
}

================
File: .gitignore
================
# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data
*.tfvars
*.tfvars.json

# Ignore override files as they are usually used to override resources locally
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Ignore CLI configuration files
.terraformrc
terraform.rc

# Ignore any .env files
*.env

# Ignore local development files
.vscode/
.idea/
