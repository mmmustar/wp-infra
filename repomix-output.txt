This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T09:00:43.019Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
ansible/
  group_vars/
    all.yml
    wordpress.yml
  inventory/
    hosts.yml
  roles/
    common/
      defaults/
        main.yml
      files/
        get_secret.py
      handlers/
        main-rch.yml
      tasks/
        main.yml
    docker/
      defaults/
        main.yml
      handlers/
        main.yml
      tasks/
        main.yml
    k3s/
      defaults/
        main.yml
      handlers/
        main.yml
      tasks/
        main.yml
    wordpress/
      defaults/
        main.yml
      tasks/
        main.yml
        secrets.yml
  ansible.cfg
  requirements.yml
  site.yml
environments/
  backend-config/
    .terraform.lock.hcl
    main.tf
    outputs.tf
    variables.tf
    versions.tf
  modules/
    compute/
      main.tf
      variables.tf
    network/
      main.tf
      outputs.tf
      security.tf
      variables.tf
    security/
      main.tf
      variables.tf
  prod/
    backend.tf
  test/
    .terraform.lock.hcl
    backend.tf
    main.tf
    variables.tf
scripts/
  ssh-update.sh
.gitignore

================================================================
Files
================================================================

================
File: ansible/group_vars/all.yml
================
# ansible/group_vars/all.yml
---
# group_vars/all.yml
vars_files:
  - vault.yml
  
timezone: UTC
environment: test
aws_access_key: "your_access_key"
aws_secret_key: "your_secret_key"
aws_region: "eu-west-3"

================
File: ansible/group_vars/wordpress.yml
================
---
wordpress_secret_name: "book"
wordpress_port: 8080
wordpress_image: wordpress:latest
wp_volume_path: /data/wordpress

================
File: ansible/inventory/hosts.yml
================
---
all:
  children:
    wordpress:
      hosts:
        wp-test:
          ansible_host: 35.180.222.29
          ansible_user: ubuntu
          ansible_ssh_private_key_file: ~/.ssh/test-aws-key-pair-new.pem
          ansible_python_interpreter: /usr/bin/python3

================
File: ansible/roles/common/defaults/main.yml
================
# roles/common/defaults/main.yml
---
system_packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - software-properties-common
  - python3-pip
  - nfs-common

================
File: ansible/roles/common/files/get_secret.py
================
#!/usr/bin/env python3
import boto3
import json
import sys

try:
    client = boto3.client('secretsmanager', region_name='eu-west-3')
    response = client.get_secret_value(SecretId='book')
    print(response['SecretString'])
except Exception as e:
    print(f"Erreur: {str(e)}", file=sys.stderr)
    sys.exit(1)

================
File: ansible/roles/common/handlers/main-rch.yml
================
# roles/common/handlers/main.yml
---
- name: restart systemd-resolved
  service:
    name: systemd-resolved
    state: restarted

================
File: ansible/roles/common/tasks/main.yml
================
# roles/common/tasks/main.yml
---
- block:
   - name: Update package cache
     apt:
       update_cache: yes
     become: true
   
   - name: Install system packages
     apt:
       name:
         - python3
         - python3-pip
         - git
         - vim
       state: present
     become: true

- name: Install boto3 and botocore locally
  pip:
   name: 
     - boto3>=1.26.0
     - botocore>=1.29.0
   state: present
  delegate_to: localhost
  become: false

================
File: ansible/roles/docker/defaults/main.yml
================
# roles/docker/defaults/main.yml
---
docker_users:
  - "{{ ansible_user }}"

================
File: ansible/roles/docker/handlers/main.yml
================
# roles/docker/handlers/main.yml
---
- name: restart docker
  service:
    name: docker
    state: restarted

================
File: ansible/roles/docker/tasks/main.yml
================
- name: Install required packages
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg-agent
      - software-properties-common
    state: present

- name: Add Docker GPG key
  apt_key:
    url: https://download.docker.com/linux/ubuntu/gpg
    state: present

- name: Add Docker repository
  apt_repository:
    repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable
    state: present

- name: Install Docker
  apt:
    name:
      - docker-ce
      - docker-ce-cli
      - containerd.io
      - docker-compose-plugin
    state: present
    update_cache: yes

- name: Start and enable Docker
  service:
    name: docker
    state: started
    enabled: yes

- name: Add users to docker group
  user:
    name: "{{ item }}"
    groups: docker
    append: yes
  with_items: "{{ docker_users }}"

- name: Configure Docker daemon
  copy:
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m",
          "max-file": "3"
        }
      }
    dest: /etc/docker/daemon.json
  notify: restart docker

================
File: ansible/roles/k3s/defaults/main.yml
================
# roles/k3s/defaults/main.yml
---
k3s_version: v1.28.4+k3s2
k3s_server_args: --disable servicelb --disable traefik

================
File: ansible/roles/k3s/handlers/main.yml
================
# roles/k3s/handlers/main.yml
---
- name: restart k3s
  service:
    name: k3s
    state: restarted

================
File: ansible/roles/k3s/tasks/main.yml
================
# roles/k3s/tasks/main.yml
---
- name: Set permissions for k3s config
  file:
   path: /etc/rancher/k3s
   mode: '0755'
   state: directory
  become: true

- name: Download k3s installer
  get_url:
   url: https://get.k3s.io
   dest: /tmp/k3s-installer
   mode: '0755'

- name: Install k3s
  command:
   cmd: /tmp/k3s-installer
   creates: /usr/local/bin/k3s
  environment:
   INSTALL_K3S_VERSION: "{{ k3s_version }}"
   INSTALL_K3S_EXEC: "{{ k3s_server_args }}"

- name: Wait for k3s to be up
  wait_for:
   path: /etc/rancher/k3s/k3s.yaml
   delay: 5
   timeout: 300

- name: Set file permissions for k3s.yaml
  file:
   path: /etc/rancher/k3s/k3s.yaml
   mode: '0644'
  become: true

- name: Create .kube directory
  file:
   path: ~/.kube
   state: directory
   mode: '0700'
  become: false

- name: Configure kubectl for the current user
  copy:
   src: /etc/rancher/k3s/k3s.yaml
   dest: ~/.kube/config
   mode: '0600'
   remote_src: yes
  become: false

- name: Test k3s installation
  command: kubectl get nodes
  register: kubectl_test
  changed_when: false
  become: false

================
File: ansible/roles/wordpress/defaults/main.yml
================
---
# Valeurs par défaut pour le rôle WordPress
wordpress_image: wordpress:latest

================
File: ansible/roles/wordpress/tasks/main.yml
================
---
- name: Create WordPress data directory
  file:
   path: "{{ wp_volume_path }}"
   state: directory
   mode: '0755'

- name: Get AWS secrets
  block:
   - name: Execute get_secret.py
     script: roles/common/files/get_secret.py
     register: secret_output
     delegate_to: localhost
     become: false
     changed_when: false

   - name: Parse JSON output and set WordPress variables
     set_fact:
       mysql_host: "{{ secret_output.stdout | from_json | json_query('MYSQL_HOST') }}" 
       mysql_user: "{{ secret_output.stdout | from_json | json_query('MYSQL_USER') }}"
       mysql_password: "{{ secret_output.stdout | from_json | json_query('MYSQL_PASSWORD') }}"
       mysql_database: "{{ secret_output.stdout | from_json | json_query('MYSQL_DATABASE') }}"
       mysql_port: "{{ secret_output.stdout | from_json | json_query('MYSQL_PORT') }}"
     no_log: true

- name: Create WordPress container
  community.docker.docker_container:
   name: wordpress
   image: "{{ wordpress_image }}"
   state: started
   restart_policy: always
   published_ports:
     - "{{ wordpress_port }}:80"
   env:
     WORDPRESS_DB_HOST: "{{ mysql_host }}:{{ mysql_port }}"
     WORDPRESS_DB_USER: "{{ mysql_user }}"
     WORDPRESS_DB_PASSWORD: "{{ mysql_password }}"
     WORDPRESS_DB_NAME: "{{ mysql_database }}"
   volumes:
     - "{{ wp_volume_path }}:/var/www/html"

================
File: ansible/roles/wordpress/tasks/secrets.yml
================
# roles/wordpress/tasks/secrets.yml
---
- name: Get AWS secrets
  block:
    - name: Execute get_secret.py
      script: roles/common/files/get_secret.py
      register: secret_output
      delegate_to: localhost
      become: false
      changed_when: false

    - name: Parse JSON output
      set_fact:
        db_secrets: "{{ secret_output.stdout | from_json }}"
      no_log: true

    - name: Set database variables
      set_fact:
        db_host: "{{ db_secrets.MYSQL_HOST }}"
        db_name: "{{ db_secrets.MYSQL_DATABASE }}"
        db_user: "{{ db_secrets.MYSQL_USER }}"
        db_password: "{{ db_secrets.MYSQL_PASSWORD }}"
      no_log: true

# roles/wordpress/tasks/main.yml
---
- name: Include secrets tasks
  include_tasks: secrets.yml

- name: Create WordPress container
  community.docker.docker_container:
    name: wordpress
    image: "{{ wordpress_image }}"
    state: started
    restart_policy: always
    published_ports:
      - "{{ wordpress_port }}:80"
    env:
      WORDPRESS_DB_HOST: "{{ db_host }}"
      WORDPRESS_DB_USER: "{{ db_user }}"
      WORDPRESS_DB_PASSWORD: "{{ db_password }}"
      WORDPRESS_DB_NAME: "{{ db_name }}"
    volumes:
      - "{{ wp_volume_path }}:/var/www/html"

================
File: ansible/ansible.cfg
================
# ansible/ansible.cfg
[defaults]
inventory = inventory/hosts.yml
private_key_file = ~/.ssh/test-aws-key-pair.pem
host_key_checking = False
remote_user = ubuntu
pkg_mgr = yum


[ssh_connection]
pipelining = True

================
File: ansible/requirements.yml
================
# requirements.yml
collections:
  - name: community.docker
  - name: community.aws
  - name: amazon.aws

================
File: ansible/site.yml
================
---
- name: Déployer l’infrastructure complète WordPress
  hosts: wordpress
  become: true
  gather_facts: true
  vars:
    ansible_pkg_mgr: apt
  roles:
    - common
    - docker
    - k3s
    - wordpress

================
File: environments/backend-config/.terraform.lock.hcl
================
# This file is maintained automatically by "terraform init".
# Manual edits may be lost in future updates.

provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.0.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:swP2uqDPi7bRLe+J4oUGEp8ZPTG4NaAV9QK+Iqgo2ro=",
  ]
}

================
File: environments/backend-config/main.tf
================
# environments/backend-config/main.tf

# Un seul bucket S3 pour tous les environnements
resource "aws_s3_bucket" "terraform_state" {
  bucket = "${var.project_name}-terraform-state"

  lifecycle {
    prevent_destroy = true
  }

  tags = {
    Name    = "${var.project_name}-terraform-state"
    Project = var.project_name
  }
}

# Activation du versioning
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}

# Activation du chiffrement
resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Blocage de l'accès public
resource "aws_s3_bucket_public_access_block" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Une seule table DynamoDB pour le verrouillage
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "${var.project_name}-terraform-locks"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = {
    Name    = "${var.project_name}-terraform-locks"
    Project = var.project_name
  }
}

================
File: environments/backend-config/outputs.tf
================
# environments/backend-config/outputs.tf
output "bucket_name" {
  description = "Nom du bucket S3 pour le state Terraform"
  value       = aws_s3_bucket.terraform_state.id
}

output "dynamodb_table_name" {
  description = "Nom de la table DynamoDB pour le verrouillage"
  value       = aws_dynamodb_table.terraform_locks.name
}

================
File: environments/backend-config/variables.tf
================
# environments/backend-config/variables.tf
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "eu-west-3"
}

variable "project_name" {
  description = "Nom du projet"
  type        = string
  default     = "wordpress-mmustar"
}

================
File: environments/backend-config/versions.tf
================
# environments/backend-config/versions.tf
terraform {
  required_version = ">= 1.0.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Project     = var.project_name
      ManagedBy   = "terraform"
    }
  }
}

================
File: environments/modules/compute/main.tf
================
// environments/modules/compute/main.tf

data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]  // Propriétaire Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

resource "aws_instance" "wordpress" {
  ami                    = data.aws_ami.ubuntu.id
  instance_type          = var.instance_type
  subnet_id              = var.subnet_id
  key_name               = var.key_name
  vpc_security_group_ids = [var.security_group_id]   // Utilise uniquement security_group_id

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  tags = {
    Name        = "${var.project_name}-instance-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

output "instance_id" {
  description = "ID of the created EC2 instance"
  value       = aws_instance.wordpress.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.wordpress.public_ip
}

output "instance_private_ip" {
  description = "Private IP of the EC2 instance"
  value       = aws_instance.wordpress.private_ip
}

================
File: environments/modules/compute/variables.tf
================
// environments/modules/compute/variables.tf

variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID where the EC2 instance will be created"
  type        = string
}

variable "subnet_id" {
  description = "Subnet ID where the EC2 instance will be created"
  type        = string
}

variable "security_group_id" {
  description = "Security Group for the EC2 instance"
  type        = string
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.medium"
}

variable "key_name" {
  description = "Name of the SSH key pair"
  type        = string
}

================
File: environments/modules/network/main.tf
================
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${var.project_name}-vpc-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name        = "${var.project_name}-igw-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_subnet" "public" {
  count                  = length(var.public_subnet_cidrs)
  vpc_id                 = aws_vpc.main.id
  cidr_block             = var.public_subnet_cidrs[count.index]
  availability_zone      = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name        = "${var.project_name}-public-subnet-${count.index + 1}-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name        = "${var.project_name}-public-rt-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

resource "aws_route_table_association" "public" {
  count = length(var.public_subnet_cidrs)

  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

data "aws_availability_zones" "available" {
  state = "available"
}

================
File: environments/modules/network/outputs.tf
================
# environments/modules/network/outputs.tf
output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}

output "vpc_id" {
  value = aws_vpc.main.id
}

output "route_table_id" {
  value = aws_route_table.public.id
}

================
File: environments/modules/network/security.tf
================
# environments/modules/network/security.tf
resource "aws_security_group" "wordpress" {
  name_prefix = "${var.project_name}-sg-${var.environment}"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]  # À restreindre selon vos besoins
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "${var.project_name}-sg-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

================
File: environments/modules/network/variables.tf
================
# environments/modules/network/variables.tf
variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
  default     = "WP"
}

# environments/modules/network/variables.tf
variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "172.16.0.0/16"  # Modifié pour éviter le conflit avec le RDS VPC
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ["172.16.1.0/24", "172.16.2.0/24"]  # Ajusté en conséquence
}

variable "existing_vpc_id" {
  description = "ID of an existing VPC. If provided, the module will use this VPC instead of creating a new one."
  type        = string
  default     = ""
}

================
File: environments/modules/security/main.tf
================
// environments/modules/security/main.tf

resource "aws_security_group" "wordpress" {
  name_prefix = "${var.project_name}-wp-${var.environment}"
  description = "Security group for WordPress instance"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTP"
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTPS"
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow SSH"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }

  tags = {
    Name        = "${var.project_name}-wp-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

output "wordpress_sg_id" {
  description = "ID of WordPress security group"
  value       = aws_security_group.wordpress.id
}

================
File: environments/modules/security/variables.tf
================
// environments/modules/security/variables.tf

variable "environment" {
  description = "Environment name (test/prod)"
  type        = string
}

variable "project_name" {
  description = "Project name for resource tagging"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID where the security groups will be created"
  type        = string
}

================
File: environments/prod/backend.tf
================
# environments/prod/backend.tf
terraform {
  backend "s3" {
    bucket         = "wordpress-mmustar-terraform-state"
    key            = "environments/prod/terraform.tfstate"
    region         = "eu-west-3"
    dynamodb_table = "wordpress-mmustar-terraform-locks"
    encrypt        = true
  }
}

================
File: environments/test/.terraform.lock.hcl
================
# This file is maintained automatically by "terraform init".
# Manual edits may be lost in future updates.

provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.0.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:swP2uqDPi7bRLe+J4oUGEp8ZPTG4NaAV9QK+Iqgo2ro=",
  ]
}

================
File: environments/test/backend.tf
================
# environments/test/backend.tf
terraform {
  backend "s3" {
    bucket         = "wordpress-mmustar-terraform-state"
    key            = "test/terraform.tfstate"
    region         = "eu-west-3"
    dynamodb_table = "wordpress-mmustar-terraform-locks"
    encrypt        = true
  }
}

================
File: environments/test/main.tf
================
// environments/test/main.tf

// Variables de déploiement (environnement et projet)
variable "environment" {
  description = "Deployment environment"
  type        = string
}

variable "project_name" {
  description = "Project name for tagging"
  type        = string
}

// Récupération du VPC existant (WP-VPC)
data "aws_vpc" "existing" {
  id = "vpc-0385cddb5bd815883"
}

// Création d'un nouveau sous-réseau dédié aux instances EC2 dans le VPC existant
resource "aws_subnet" "compute" {
  vpc_id                  = data.aws_vpc.existing.id
  cidr_block              = "10.0.100.0/24"  // Sous-ensemble du VPC (par ex. 10.0.0.0/16)
  availability_zone       = "eu-west-3a"
  map_public_ip_on_launch = true

  tags = {
    Name        = "${var.project_name}-compute-subnet-${var.environment}"
    Environment = var.environment
    Project     = var.project_name
  }
}

// Appel du module Security en lui passant le VPC existant
module "security" {
  source       = "../modules/security"
  environment  = var.environment
  project_name = var.project_name
  vpc_id       = data.aws_vpc.existing.id
}

// Appel du module Compute en lui passant le VPC existant, le sous-réseau créé, et le SG défini dans le module Security
module "compute" {
  source            = "../modules/compute"
  environment       = var.environment
  project_name      = var.project_name
  vpc_id            = data.aws_vpc.existing.id
  subnet_id         = aws_subnet.compute.id
  security_group_id = module.security.wordpress_sg_id   // On passe ici l'ID du SG via security_group_id
  instance_type     = "t3.medium"
  key_name          = "test-aws-key-pair-new"
}

// Association de l'EIP existante à l'instance EC2
resource "aws_eip_association" "wordpress_eip_assoc" {
  instance_id   = module.compute.instance_id
  allocation_id = "eipalloc-0933b219497dd6c15"
}

// Récupération de l'EIP existante via un data source
data "aws_eips" "wordpress" {
  filter {
    name   = "allocation-id"
    values = ["eipalloc-0933b219497dd6c15"]
  }
}

// Utilisation de la base de données RDS existante
data "aws_db_instance" "wordpress" {
  db_instance_identifier = "wordpress-db"
}

// Exports
output "rds_endpoint" {
  value = data.aws_db_instance.wordpress.endpoint
}

output "instance_public_ip" {
  value = module.compute.instance_public_ip
}

output "instance_id" {
  value = module.compute.instance_id
}

output "eip_public_ip" {
  description = "Public IP of the associated existing EIP"
  value       = data.aws_eips.wordpress.public_ips[0]
}

================
File: environments/test/variables.tf
================
// environments/test/variables.tf

variable "aws_region" {
  description = "AWS Region"
  type        = string
  default     = "eu-west-3"
}

variable "key_name" {
  description = "SSH key pair name"
  type        = string
  default     = "test-aws-key-pair-new"
}

================
File: scripts/ssh-update.sh
================
#!/bin/bash

# Configuration par défaut
SSH_KEY_PATH="/home/gnou/.ssh/test-aws-key-pair-new.pem"
EC2_USER="ubuntu"
KNOWN_HOSTS="/home/gnou/.ssh/known_hosts"

# Fonction d'aide
show_usage() {
    echo "Usage: $0 [OPTIONS] EC2_IP_ADDRESS"
    echo "Options:"
    echo "  -k, --key PATH    Chemin vers la clé SSH (default: $SSH_KEY_PATH)"
    echo "  -u, --user USER   Utilisateur EC2 (default: $EC2_USER)"
    echo "  -h, --help        Affiche cette aide"
    exit 1
}

# Traitement des arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -k|--key)
            SSH_KEY_PATH="$2"
            shift 2
            ;;
        -u|--user)
            EC2_USER="$2"
            shift 2
            ;;
        -h|--help)
            show_usage
            ;;
        *)
            EC2_IP="$1"
            shift
            ;;
    esac
done

# Vérification des paramètres requis
if [ -z "$EC2_IP" ]; then
    echo "Erreur: Adresse IP de l'instance EC2 manquante"
    show_usage
fi

if [ ! -f "$SSH_KEY_PATH" ]; then
    echo "Erreur: Clé SSH non trouvée: $SSH_KEY_PATH"
    exit 1
fi

# Fonction pour vérifier si l'instance est accessible
check_instance() {
    timeout 5 nc -zv $EC2_IP 22 &>/dev/null
    return $?
}

# Attendre que l'instance soit accessible
echo "Vérification de l'accessibilité de l'instance..."
ATTEMPTS=0
MAX_ATTEMPTS=10

while ! check_instance; do
    ATTEMPTS=$((ATTEMPTS + 1))
    if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
        echo "Erreur: Impossible de se connecter à l'instance après $MAX_ATTEMPTS tentatives"
        exit 1
    fi
    echo "Instance non accessible, nouvelle tentative dans 5 secondes... ($ATTEMPTS/$MAX_ATTEMPTS)"
    sleep 5
done

# Supprimer l'ancienne clé host si elle existe
if ssh-keygen -F $EC2_IP >/dev/null 2>&1; then
    echo "Suppression de l'ancienne clé host..."
    ssh-keygen -f "$KNOWN_HOSTS" -R "$EC2_IP" >/dev/null 2>&1
fi

# Tentative de connexion
echo "Connexion à l'instance $EC2_IP..."
ssh -o StrictHostKeyChecking=accept-new \
    -o ConnectTimeout=10 \
    -i "$SSH_KEY_PATH" \
    "$EC2_USER@$EC2_IP"

exit_code=$?
if [ $exit_code -ne 0 ]; then
    echo "Erreur lors de la connexion (code: $exit_code)"
    exit $exit_code
fi

================
File: .gitignore
================
# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data
*.tfvars
*.tfvars.json

# Ignore override files as they are usually used to override resources locally
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Ignore CLI configuration files
.terraformrc
terraform.rc

# Ignore any .env files
*.env

# Ignore local development files
.vscode/
.idea/

repomix-output.txt
vault.yml
